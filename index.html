<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>ç‹—ç‹—åƒéª¨é ­ï½œDog Park Snake</title>
  <style>
    body {
      margin: 0;
      background: #000;
      color: #fff;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }
    .wrapper {
      text-align: center;
    }
    canvas {
      border-radius: 12px;
      box-shadow: 0 0 20px rgba(0,0,0,0.5);
      background: #000;
      display: block;
      margin: 0 auto 10px;
    }
    .hint {
      font-size: 14px;
      color: #ddd;
    }
  </style>
</head>
<body>
<div class="wrapper">
  <canvas id="game"></canvas>
  <div class="hint">
    âŒ¨ï¸ æ–¹å‘éµ / WASD æ§åˆ¶ç‹—ç‹—ã€€|ã€€R é‡æ–°é–‹å§‹<br>
    ğŸ¦´ æ¯ 10 åˆ†å‡ºç¾ã€Œå¤§éª¨é ­ bonusã€ (+3 åˆ†)ã€€
    ğŸ¶ åƒåˆ°éª¨é ­æœƒæœ‰éŸ³æ•ˆ ï¼‹ æ„›å¿ƒ
  </div>
</div>

<script>
  // --- éŸ³æ•ˆåˆå§‹åŒ–ï¼ˆbone.wav / gameover_waiwai.wav è¦è·Ÿ index.html æ”¾åŒä¸€å€‹è³‡æ–™å¤¾ï¼‰ ---
  const boneSound     = new Audio("bone.wav");
  const gameoverSound = new Audio("gameover_waiwai.wav");
  boneSound.volume     = 0.9;
  gameoverSound.volume = 0.9;
  boneSound.load();
  gameoverSound.load();

  // --- è§£é™¤ Chrome/Safari è‡ªå‹•æ’­æ”¾å°é–ï¼ˆç¬¬ä¸€æ¬¡æŒ‰éµæ™‚å·æ‹¿æ¬Šé™ï¼Œä¸å‡ºè²ï¼‰---
  document.addEventListener("keydown", () => {
    boneSound.play()
      .then(() => {
        boneSound.pause();
        boneSound.currentTime = 0;
      })
      .catch(() => {});
    gameoverSound.play()
      .then(() => {
        gameoverSound.pause();
        gameoverSound.currentTime = 0;
      })
      .catch(() => {});
  }, { once: true });

  // --- éŠæˆ²è¨­å®š ---
  const CELL_SIZE   = 24;
  const GRID_WIDTH  = 30;
  const GRID_HEIGHT = 30;
  const WIDTH  = CELL_SIZE * GRID_WIDTH;
  const HEIGHT = CELL_SIZE * GRID_HEIGHT;
  const SPEED  = 120; // ms

  const SKY_COLOR   = "#9fd5ff";
  const GRASS_COLOR = "#15803d";
  const PATH_COLOR  = "#4b5563";

  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  canvas.width  = WIDTH;
  canvas.height = HEIGHT;

  // ç‹€æ…‹
  let snake;
  let direction;
  let pendingDirection;
  let food;
  let score;
  let gameOver;
  let bonusFood;          // æ¯ 10 åˆ†ã€Œå¤§éª¨é ­ã€
  let heartEffects = [];  // {x, y, life}

  function resetGame() {
    snake = [
      { x: Math.floor(GRID_WIDTH / 2),     y: Math.floor(GRID_HEIGHT / 2) },
      { x: Math.floor(GRID_WIDTH / 2) - 1, y: Math.floor(GRID_HEIGHT / 2) },
      { x: Math.floor(GRID_WIDTH / 2) - 2, y: Math.floor(GRID_HEIGHT / 2) },
    ];
    direction        = { x: 1, y: 0 };
    pendingDirection = { x: 1, y: 0 };
    food       = randomFoodPosition();
    score      = 0;
    gameOver   = false;
    bonusFood  = false;
    heartEffects = [];
  }

  function randomFoodPosition() {
    while (true) {
      const x = Math.floor(Math.random() * GRID_WIDTH);
      const y = Math.floor(Math.random() * GRID_HEIGHT);
      if (!snake.some(s => s.x === x && s.y === y)) {
        return { x, y };
      }
    }
  }

  function changeDirection(dx, dy) {
    const curDx = direction.x;
    const curDy = direction.y;
    // é˜²æ­¢ 180 åº¦è½‰å‘
    if (dx === -curDx && dy === -curDy) return;
    pendingDirection = { x: dx, y: dy };
  }

  document.addEventListener("keydown", e => {
    switch (e.key) {
      case "ArrowUp":
      case "w":
      case "W":
        changeDirection(0, -1);
        break;
      case "ArrowDown":
      case "s":
      case "S":
        changeDirection(0, 1);
        break;
      case "ArrowLeft":
      case "a":
      case "A":
        changeDirection(-1, 0);
        break;
      case "ArrowRight":
      case "d":
      case "D":
        changeDirection(1, 0);
        break;
      case "r":
      case "R":
        if (gameOver) resetGame();
        break;
      default:
        break;
    }
  });

  function moveSnake() {
    const head = snake[0];
    const dx = direction.x;
    const dy = direction.y;
    const newHead = { x: head.x + dx, y: head.y + dy };

    // æ’ç‰†
    if (
      newHead.x < 0 || newHead.x >= GRID_WIDTH ||
      newHead.y < 0 || newHead.y >= GRID_HEIGHT
    ) {
      endGame();
      return;
    }

    // æ’åˆ°è‡ªå·±
    if (snake.some(s => s.x === newHead.x && s.y === newHead.y)) {
      endGame();
      return;
    }

    // å‰é€²ï¼šé ­æ”¾å‰é¢
    snake.unshift(newHead);

    // åƒåˆ°éª¨é ­
    if (newHead.x === food.x && newHead.y === food.y) {
      // åˆ†æ•¸ï¼šæ™®é€š +1ï¼Œå¤§éª¨é ­ +3
      if (bonusFood) {
        score += 3;
      } else {
        score += 1;
      }

      // æ’­æ”¾å’¬éª¨é ­éŸ³æ•ˆ
      try {
        boneSound.currentTime = 0;
        boneSound.play();
      } catch (e) {}

      // æ„›å¿ƒç‰¹æ•ˆï¼šå¾ç‹—ç‹—é ­ä½ç½®å¾€ä¸Šé£„
      const hx = newHead.x * CELL_SIZE + CELL_SIZE / 2;
      const hy = newHead.y * CELL_SIZE + CELL_SIZE / 2;
      heartEffects.push({ x: hx, y: hy, life: 12 });

      // ç”Ÿæˆä¸‹ä¸€å¡Šéª¨é ­
      food = randomFoodPosition();

      // æ¯ 10ã€20ã€30â€¦åˆ† â†’ ä¸‹ä¸€é¡†æ˜¯å¤§éª¨é ­
      bonusFood = (score % 10 === 0);
    } else {
      // æ²’åƒåˆ°å°±ç§»é™¤å°¾å·´
      snake.pop();
    }
  }

  function endGame() {
    if (!gameOver) {
      gameOver = true;
      try {
        gameoverSound.currentTime = 0;
        gameoverSound.play();
      } catch (e) {}
    }
  }

  // èƒŒæ™¯ï¼šå¤©ç©ºå¾ 0 é–‹å§‹ï¼Œæ²’æœ‰ä¸Šæ–¹ç•™ç™½
  function drawBackground() {
    // å¤©ç©º
    ctx.fillStyle = SKY_COLOR;
    ctx.fillRect(0, 0, WIDTH, HEIGHT * 0.4);

    // è‰åœ°
    ctx.fillStyle = GRASS_COLOR;
    ctx.fillRect(0, HEIGHT * 0.4, WIDTH, HEIGHT * 0.6);

    // å°è·¯
    const pathWidth = CELL_SIZE * 4;
    ctx.fillStyle = PATH_COLOR;
    ctx.fillRect(
      WIDTH / 2 - pathWidth / 2,
      HEIGHT * 0.4,
      pathWidth,
      HEIGHT * 0.6
    );

    // æ¨¹æœ¨
    const treeXs = [CELL_SIZE * 3, CELL_SIZE * 7, CELL_SIZE * 22, CELL_SIZE * 26];
    for (const x of treeXs) {
      // æ¨¹å¹¹
      ctx.fillStyle = "#92400e";
      ctx.fillRect(x - 6, HEIGHT * 0.4 - 10, 12, 40);

      // æ¨¹å† 
      ctx.beginPath();
      ctx.fillStyle = "#16a34a";
      ctx.ellipse(
        x,
        HEIGHT * 0.4 - 20,
        20,
        24,
        0,
        0,
        Math.PI * 2
      );
      ctx.fill();
    }

    // å¤ªé™½
    ctx.font = "28px 'Apple Color Emoji'";
    ctx.fillText("â˜€ï¸", WIDTH - 60, 45);
  }

  function draw() {
    ctx.clearRect(0, 0, WIDTH, HEIGHT);

    // èƒŒæ™¯
    drawBackground();

    // åˆ†æ•¸ï¼ˆç´”ç™½å­—ï¼Œç•«åœ¨å¤©ç©ºä¸Šï¼‰
    ctx.font = "22px -apple-system, 'Segoe UI Emoji'";
    ctx.fillStyle = "#ffffff";
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    ctx.fillText("Score: " + score, 10, 40);

    // é£Ÿç‰©ï¼ˆéª¨é ­ / å¤§éª¨é ­ï¼‰
    const fx = food.x * CELL_SIZE + CELL_SIZE / 2;
    const fy = food.y * CELL_SIZE + CELL_SIZE / 2;

    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.font = bonusFood
      ? "32px 'Apple Color Emoji'"
      : "24px 'Apple Color Emoji'";
    ctx.fillText("ğŸ¦´", fx, fy);

    // è›‡ï¼ˆç‹—ç‹—ï¼‰
    for (let i = 0; i < snake.length; i++) {
      const seg = snake[i];
      const cx = seg.x * CELL_SIZE + CELL_SIZE / 2;
      const cy = seg.y * CELL_SIZE + CELL_SIZE / 2;

      ctx.font = "24px 'Apple Color Emoji'";
      ctx.fillText("ğŸ•", cx, cy);
    }

    // â¤ï¸ æ„›å¿ƒç‰¹æ•ˆ
    const newHearts = [];
    for (const h of heartEffects) {
      ctx.font = "20px 'Apple Color Emoji'";
      ctx.fillText("â¤ï¸", h.x, h.y);
      h.y -= 2;
      h.life -= 1;
      if (h.life > 0) newHearts.push(h);
    }
    heartEffects = newHearts;

    // Game Over ç•«é¢
    if (gameOver) {
      ctx.fillStyle = "rgba(15,23,42,0.9)";
      const w = 280, h = 120;
      const x = WIDTH / 2 - w / 2;
      const y = HEIGHT / 2 - h / 2;

      ctx.fillRect(x, y, w, h);
      ctx.strokeStyle = "white";
      ctx.strokeRect(x, y, w, h);

      ctx.textAlign = "center";
      ctx.fillStyle = "#f97373";
      ctx.font = "28px Arial";
      ctx.fillText("Game Over", WIDTH / 2, HEIGHT / 2 - 10);

      ctx.font = "16px Arial";
      ctx.fillStyle = "#ffffff";
      ctx.fillText("æŒ‰ R é‡æ–°é–‹å§‹", WIDTH / 2, HEIGHT / 2 + 25);
    }
  }

  // ğŸ” éŠæˆ²ä¸»è¿´åœˆ
  function gameLoop() {
    if (!gameOver) {
      direction = { ...pendingDirection };
      moveSnake();
    }
    draw();
  }

  // å•Ÿå‹•
  resetGame();
  setInterval(gameLoop, SPEED);
</script>
</body>
</html>
